<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>我的時光寶物架 - 關卡模式</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    @font-face { font-family: 'pixel-font'; src: url('https://fonts.gstatic.com/s/pressstart2p/v12/e3t4euO8KNyBfB3R0rGJ.ttf') format('truetype'); }
    body { margin: 0; background: #222; font-family: Arial, 'pixel-font', monospace; letter-spacing: 1px; overflow-x: hidden; }
    .crt-bg { background-image: url('assets/your-background.jpg'); background-size: cover; background-position: center; background-repeat: no-repeat; min-height: 100vh; width: 100vw; position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; }
    .main-frame { position: relative; width: 90vw; max-width: 540px; margin: 20px auto; padding: 1.5em; background: rgba(35, 38, 50, 0.95); box-shadow: 0 0 80px #444, 0 0 0 6px #fce26a inset; border-radius: 18px; z-index: 2; box-sizing: border-box; }
    .game-hud { display: flex; justify-content: space-between; align-items: center; color: #fff; font-size: 1.1em; padding: 0 10px 10px; }
    .pause-btn { background: none; border: 2px solid #ffc; color: #ffc; border-radius: 5px; font-family: inherit; font-size: 1em; cursor: pointer; }
    .title-screen, .game-over-screen { text-align: center; padding: 40px 0; }
    .shelf { display: flex; justify-content: center; align-items: center; margin: 1.5em 0; gap: 15px; min-height: 120px; }
    .shelf-slot { background-image: url('assets/shelf-bg.jpg'); background-size: cover; background-position: center; border: 3px solid #6b4f2c; width: 100px; height: 100px; box-shadow: 0 4px 15px rgba(0,0,0,0.5), 0 2px 4px rgba(0,0,0,0.3) inset; display: flex; align-items: center; justify-content: center; border-radius: 10px; position: relative; padding: 10px; box-sizing: border-box; }
    .item-realistic { width: 100%; height: 100%; object-fit: contain; filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.4)); }
    .timer-bar-container { height: 6px; background: #444; border-radius: 3px; margin: 1em 0; }
    .timer-bar { height: 100%; background: linear-gradient(90deg, #ffec9e, #fce26a); border-radius: 3px; transition: width 0.2s linear; }
    .price-btn { font-size: 1em; margin: 0.5em; background: #ffe5b5; border: 2px solid #f9df5b; color: #1d1821; border-radius: 8px; padding: 0.5em 1em; cursor: pointer; }
    .feedback { text-align: center; font-size: 1.8em; color: #ffb96d; min-height: 50px; display:flex; align-items:center; justify-content:center; }
    .pixel-font { font-family: 'pixel-font', monospace; letter-spacing: 2px; }
    .pause-overlay, .tutorial-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(26, 32, 44, 0.85); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .pause-menu, .tutorial-modal { background: #E2E8F0; color: #1A202C; padding: 30px; border-radius: 12px; width: 90%; max-width: 450px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); border: 2px solid #F7FAFC; position: relative; font-family: 'Noto Sans TC', sans-serif; text-align: center; }
    .tutorial-close-btn { position: absolute; top: 10px; right: 15px; background: none; border: none; font-size: 16px; color: #555; cursor: pointer; font-family: inherit; }
    .pause-menu h2, .tutorial-content h4 { font-family: 'VT323', monospace; color: #1A202C; font-size: 2em; margin-top: 10px; margin-bottom: 20px; text-align: center; }
    @media (max-width: 600px) { body { overflow: auto; } .main-frame { width: 95vw; height: auto; min-height: 90vh; margin: auto; padding: 1em; display: flex; flex-direction: column; } h1 { font-size: clamp(1.5em, 6vw, 2em); } .title-screen, .game-over-screen { margin-top: 0; flex-grow: 1; display: flex; flex-direction: column; justify-content: center; } .shelf { gap: 10px; flex-wrap: wrap; height: auto; } .shelf-slot { width: 28vw; height: 28vw; } .pixel-font { font-size: clamp(1.2em, 4vw, 1.8em); } .price-btn { font-size: 1.1em; padding: 0.8em 1em; margin: 0.5em; } .feedback { font-size: clamp(1.5em, 5vw, 2em); margin-top: 20px; } }
  </style>
</head>
<body>
  <div id="root"></div>
  <audio id="sfx-coin" src="audio/sfx-coin.mp3"></audio>
  <audio id="sfx-wrong" src="audio/sfx-wrong.mp3"></audio>
  <audio id="sfx-vhs" src="audio/sfx-vhs.mp3"></audio>
  <audio id="sfx-modem" src="audio/sfx-modem.mp3"></audio>
  <audio id="bgm-main" src="audio/bgm-chiptune1.mp3" loop></audio>
  
  <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js"></script>
  
  <script>
    const e = React.createElement;
    const nostalgicItems = [ { name: "Game Boy", img: "assets/gameboy.jpeg", value: 2800 }, { name: "B.B. Call 傳呼機", img: "assets/bb-call.webp", value: 1800 }, { name: "3.5吋磁碟片", img: "assets/floppydisk.jpeg", value: 15 }, { name: "Tamagotchi 電子雞", img: "assets/tamagotchi.jpeg", value: 700 }, { name: "王子麵", img: "assets/prince-noodles.png", value: 3 }, { name: "養樂多", img: "assets/yakult.jpg", value: 2 }, ];
    const levelConfig = [ { level: 1, items: 3, memoryTime: 6000, mode: "FIND_DIFF" }, { level: 2, items: 3, memoryTime: 5000, mode: "FIND_DIFF" }, { level: 3, items: 4, memoryTime: 5000, mode: "ESTIMATE_PRICE" }, { level: 4, items: 4, memoryTime: 4000, mode: "FIND_DIFF" }, { level: 5, items: 5, memoryTime: 4000, mode: "ESTIMATE_PRICE" }, ];
    
    function getRandomItems(n) { const arr = nostalgicItems.slice(); const items = []; while (items.length < n && arr.length > 0) { const idx = Math.floor(Math.random() * arr.length); items.push(arr.splice(idx, 1)[0]); } return items; }
    function getShuffledItems(items) { const arr = items.slice(); const idx = Math.floor(Math.random() * arr.length); let newItem; do { newItem = nostalgicItems[Math.floor(Math.random() * nostalgicItems.length)]; } while (arr.find((x) => x.name === newItem.name)); arr[idx] = newItem; return { changedItems: arr, changedIdx: idx }; }
    
    // ★★★ Bug修正 ★★★
    function getModePrompt(mode, items) {
      if (mode === "FIND_DIFF") {
        const { changedItems, changedIdx } = getShuffledItems(items);
        return { prompt: "咦？是不是有東西被換掉了？", answer: changedIdx, changedItems };
      } else if (mode === "ESTIMATE_PRICE") {
        const idx = Math.floor(Math.random() * items.length);
        const item = items[idx];
        const correct = item.value;
        let choices = [ correct, correct + 500, Math.max(correct - 500, 1), correct + 1000 ].sort(()=>Math.random()-0.5);
        const answer = choices.indexOf(correct);
        const prompt = `猜猜看，${item.name}在當年大概多少錢？`;
        // 修正：將 itemIndex 一併回傳
        return { prompt, answer, choices: choices.map((v) => `${v} 元`), item, itemIndex: idx };
      }
    }

    const sfxElements = { coin: () => document.getElementById("sfx-coin"), wrong: () => document.getElementById("sfx-wrong"), vhs: () => document.getElementById("sfx-vhs"), modem: () => document.getElementById("sfx-modem"), };
    function playSfx(name) { const el = sfxElements[name](); if (el) { el.currentTime = 0; el.play().catch(()=>{}); } }
    const getBGM = () => document.getElementById("bgm-main");

    function TutorialModal({ onClose }) { const content = e('div', { className: 'tutorial-content' }, e('h4', null, '玩法說明'), e('div', { className: 'tutorial-image-placeholder' }, e('p', { style: { fontSize: '1.2em', color: '#E59866' } }, '[ 玩法說明圖 ]'), e('ul', null, e('li', null, '1. 記住貨架上出現的所有寶物！'), e('li', null, '2. 找出被調包的物品，或猜出物品的當年價格！')))); return e('div', { className: 'tutorial-overlay' }, e('div', { className: 'tutorial-modal' }, e('button', { className: 'tutorial-close-btn', onClick: onClose }, '我知道了 (略過)'), content)); }
    
    function App() {
      const [isTutorialVisible, setTutorialVisible] = React.useState(false);
      const [isAudioUnlocked, setAudioUnlocked] = React.useState(false);
      const [isPaused, setPaused] = React.useState(false);
      const [gameStatus, setGameStatus] = React.useState("TITLE");
      const [currentLevel, setCurrentLevel] = React.useState(1);
      const [lives, setLives] = React.useState(3);
      const [phase, setPhase] = React.useState('IDLE');
      const [shelfItems, setShelfItems] = React.useState([]);
      const [hiddenShelfItems, setHiddenShelfItems] = React.useState([]);
      const [answer, setAnswer] = React.useState(null);
      const [mode, setMode] = React.useState("FIND_DIFF");
      const [prompt, setPrompt] = React.useState("");
      const [questionData, setQuestionData] = React.useState(null);
      const [feedback, setFeedback] = React.useState("");

      const tutorialKey = 'tutorialShown_nostalgic_memory_v3';
      React.useEffect(() => { if (!sessionStorage.getItem(tutorialKey)) setTutorialVisible(true); }, []);
      const handleCloseTutorial = () => { setTutorialVisible(false); sessionStorage.setItem(tutorialKey, 'true'); unlockAudio(); };
      const unlockAudio = () => { if (isAudioUnlocked) return; Object.values(sfxElements).forEach(getEl => { const el = getEl(); if (el) { el.play().catch(() => {}); el.pause(); } }); const bgmEl = getBGM(); if (bgmEl) { bgmEl.play().catch(() => {}); bgmEl.pause(); } setAudioUnlocked(true); };

      const bgm = React.useMemo(() => getBGM(), []);
      React.useEffect(() => {
          if (isAudioUnlocked && !isPaused && (gameStatus === 'PLAYING' || gameStatus === 'LEVEL_CLEAR')) {
              if (bgm && bgm.paused) bgm.play().catch(()=>{});
          } else {
              if (bgm) bgm.pause();
          }
      }, [isAudioUnlocked, isPaused, gameStatus, bgm]);

      const timerRef = React.useRef(null);
      const startLevel = (levelNum) => {
        if (isPaused) return;
        const config = levelConfig[levelNum - 1];
        if (!config) { setGameStatus("GAME_OVER_WIN"); return; }
        setFeedback(""); setGameStatus("PLAYING"); setPhase("MEMORY"); setMode(config.mode);
        const items = getRandomItems(config.items);
        setShelfItems(items);
        if (timerRef.current) clearTimeout(timerRef.current);
        timerRef.current = setTimeout(() => {
          if (isPaused) return;
          playSfx('vhs'); setPhase('QUESTION');
          const qData = getModePrompt(config.mode, items);
          setPrompt(qData.prompt); setAnswer(qData.answer); setQuestionData(qData);
          if (config.mode === "FIND_DIFF") setHiddenShelfItems(qData.changedItems);
        }, config.memoryTime);
      };
      
      const handleAnswer = (isCorrect) => {
        if (phase !== 'QUESTION') return;
        setPhase('IDLE');
        if (isCorrect) {
          playSfx('coin'); setFeedback(`關卡 ${currentLevel} 完成！`);
          setTimeout(() => setCurrentLevel(prev => prev + 1), 800);
        } else {
          playSfx('wrong'); const newLives = lives - 1; setLives(newLives);
          if (newLives > 0) {
            setFeedback("答錯了！再試一次！"); setTimeout(() => startLevel(currentLevel), 800);
          } else {
            setFeedback("生命值耗盡！"); setGameStatus("GAME_OVER_LOSE");
          }
        }
      };

      React.useEffect(() => {
        if(gameStatus === 'PLAYING') startLevel(currentLevel);
      }, [currentLevel, gameStatus]);
      
      const resetGame = () => { unlockAudio(); setCurrentLevel(1); setLives(3); setFeedback(''); setPaused(false); setGameStatus('PLAYING'); };
      const returnToTitle = () => { setCurrentLevel(1); setLives(3); setFeedback(''); setGameStatus('TITLE'); };
      
      const renderShelf = (items, clickable) => e("div", { className: "shelf" }, items.map((item, i) => e("div", { key: i, className: "shelf-slot", style: { cursor: clickable ? "pointer" : "default" }, onClick: () => clickable && handleAnswer(i === answer) }, item && e("img", { src: item.img, alt: item.name, className: "item-realistic" }))));
      
      const renderGameContent = () => {
        if (feedback) return e("div", { className: "feedback pixel-font" }, feedback);
        const config = levelConfig[currentLevel - 1] || {};
        const isMemoryPhase = phase === 'MEMORY';
        
        let questionShelf;
        if (!isMemoryPhase && mode === "ESTIMATE_PRICE" && questionData) {
            const displayItems = shelfItems.map((item, i) => (i === questionData.itemIndex) ? item : null);
            questionShelf = renderShelf(displayItems, false);
        } else {
            questionShelf = renderShelf(hiddenShelfItems, true);
        }

        return e(React.Fragment, null,
          e("div", { className: "game-hud" }, e("span", null, `關卡: ${currentLevel}/${levelConfig.length}`), e("span", null, `生命值: ${'♥'.repeat(lives)}`), e("button", { className: 'pause-btn', onClick: () => setPaused(true) }, '|| 暫停')),
          e("div", { className: "pixel-font", style: { color: isMemoryPhase ? "#E383B9" : "#6EDCFF", minHeight: '40px' } }, isMemoryPhase ? "記住貨架上的寶物吧！" : prompt),
          isMemoryPhase ? renderShelf(shelfItems, false) : (mode === "FIND_DIFF" ? renderShelf(hiddenShelfItems, true) : questionShelf),
          isMemoryPhase && e("div", { className: "timer-bar-container" }, e("div", { className: "timer-bar", style: { animation: `timer-bar ${config.memoryTime}ms linear` } })),
          !isMemoryPhase && mode === "ESTIMATE_PRICE" && e("div", { style: { textAlign: 'center' } }, questionData.choices.map((c, i) => e("button", { key: i, className: "pixel-font price-btn", onClick: () => handleAnswer(i === answer) }, c)))
        );
      };
      
      const renderScreen = () => {
        switch (gameStatus) {
          case 'TITLE': return e("div", { className: "title-screen" }, e("h1", { className: "pixel-font", style: { color: "#F9DF5B" } }, "我的時光寶物架"), e("p", { style: { color: "#E383B9" } }, "關卡挑戰模式"), e("button", { className: "pixel-font", onClick: resetGame }, "開始遊戲"));
          case 'PLAYING': return renderGameContent();
          case 'GAME_OVER_WIN': return e("div", { className: 'game-over-screen' }, e("h2", {style:{color:"#F9DF5B"}}, "恭喜！"), e("p", {style:{color:"#fff"}}, "您已完成所有挑戰！"), e("button", { className: "pixel-font", onClick: returnToTitle }, "返回主選單"));
          case 'GAME_OVER_LOSE': return e("div", { className: 'game-over-screen' }, e("h2", {style:{color:"#ff6b6b"}}, "遊戲結束"), e("p", {style:{color:"#fff"}}, "別氣餒，再試一次吧！"), e("button", { className: "pixel-font", onClick: resetGame }, "重新開始"));
          default: return e("div", { className: "feedback" }, "載入中...");
        }
      }

      return e("div", { className: "crt-bg", onClick: unlockAudio },
        isTutorialVisible && e(TutorialModal, { onClose: handleCloseTutorial }),
        isPaused && e("div", { className: "pause-overlay" }, e("div", { className: "pause-menu" }, e("h2", null, "遊戲已暫停"), e("button", { className: "price-btn", onClick: () => setPaused(false) }, "繼續遊戲"), e("button", { className: "price-btn", onClick: returnToTitle }, "返回主選單"))),
        !isTutorialVisible && e("div", { className: "main-frame" }, renderScreen())
      );
    }
    ReactDOM.createRoot(document.getElementById("root")).render(e(App));
  </script>
</body>
</html>
